# Slack notification on merge to main or staging
# Waits for Vercel deployment to succeed, then collects all commits,
# rephrases them in customer-friendly language via AI, and posts to Slack.
#
# Required secrets (already set for saship-digest):
#   AI_GATEWAY_API_KEY   — Vercel AI Gateway API key
#   SLACK_WEBHOOK_URL    — Slack incoming webhook

name: Slack Merge Notify

on:
  push:
    branches: [main, staging]

jobs:
  notify:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Wait for Vercel deployment
        id: vercel
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          SHA="${{ github.sha }}"
          echo "Waiting for Vercel deployment on $SHA..."

          MAX_WAIT=600  # 10 minutes
          INTERVAL=20
          ELAPSED=0

          while [ "$ELAPSED" -lt "$MAX_WAIT" ]; do
            # Check deployment statuses on this commit (Vercel creates these)
            STATUSES=$(gh api "/repos/${{ github.repository }}/deployments?sha=$SHA&per_page=5" 2>/dev/null || echo "[]")

            # Look for a Vercel deployment
            DEPLOY_ID=$(echo "$STATUSES" | jq -r '[.[] | select(.creator.login == "vercel[bot]" or .environment == "Production" or .environment == "Preview")] | first | .id // empty')

            if [ -n "$DEPLOY_ID" ]; then
              # Check the status of this deployment
              STATE=$(gh api "/repos/${{ github.repository }}/deployments/$DEPLOY_ID/statuses?per_page=1" 2>/dev/null \
                | jq -r '.[0].state // "pending"')

              echo "Deployment $DEPLOY_ID state: $STATE (${ELAPSED}s elapsed)"

              if [ "$STATE" = "success" ]; then
                echo "deploy_ok=true" >> "$GITHUB_OUTPUT"
                DEPLOY_URL=$(gh api "/repos/${{ github.repository }}/deployments/$DEPLOY_ID/statuses?per_page=1" \
                  | jq -r '.[0].environment_url // empty')
                echo "deploy_url=$DEPLOY_URL" >> "$GITHUB_OUTPUT"
                exit 0
              elif [ "$STATE" = "failure" ] || [ "$STATE" = "error" ]; then
                echo "::error::Vercel deployment failed"
                echo "deploy_ok=false" >> "$GITHUB_OUTPUT"
                exit 0
              fi
            else
              echo "No Vercel deployment found yet (${ELAPSED}s elapsed)"
            fi

            sleep "$INTERVAL"
            ELAPSED=$((ELAPSED + INTERVAL))
          done

          echo "::warning::Timed out waiting for Vercel deployment"
          echo "deploy_ok=timeout" >> "$GITHUB_OUTPUT"

      - name: Collect merge commits
        if: steps.vercel.outputs.deploy_ok == 'true'
        id: commits
        run: |
          BEFORE="${{ github.event.before }}"
          AFTER="${{ github.event.after }}"

          # If before is all zeros (new branch), just use the head commit
          if echo "$BEFORE" | grep -qE '^0+$'; then
            COMMITS=$(git log -1 --pretty=format:'%s' "$AFTER")
          else
            COMMITS=$(git log --pretty=format:'%s' "${BEFORE}..${AFTER}")
          fi

          if [ -z "$COMMITS" ]; then
            echo "no_commits=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "no_commits=false" >> "$GITHUB_OUTPUT"
          echo "commits<<EOF" >> "$GITHUB_OUTPUT"
          echo "$COMMITS" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Rephrase with AI
        if: steps.vercel.outputs.deploy_ok == 'true' && steps.commits.outputs.no_commits != 'true'
        id: ai
        env:
          AI_GATEWAY_API_KEY: ${{ secrets.AI_GATEWAY_API_KEY }}
          RAW_COMMITS: ${{ steps.commits.outputs.commits }}
        run: |
          BRANCH="${GITHUB_REF_NAME}"

          if [ "$BRANCH" = "main" ]; then
            ENV_LABEL="production"
          else
            ENV_LABEL="staging"
          fi

          cat > /tmp/prompt.txt <<PROMPT_EOF
          Tu rediges une mise a jour Slack detaillee pour des personnes non-techniques (fondateurs, chefs de projet, clients).

          De nouveaux changements viennent d'etre deployes en ${ENV_LABEL}. Voici les messages de commit bruts :

          ${RAW_COMMITS}

          Reecris-les sous forme d'une liste a puces detaillee (format Slack mrkdwn) comprehensible par une personne non-technique.
          Regles :
          - Ecris en francais
          - Utilise un langage simple : ce qui a change pour l'utilisateur ou le produit, pas comment c'est code
          - Aucun jargon technique (pas de "refactor", "fix lint", "bump deps", "merge branch", "CI", etc.)
          - Explique TOUS les changements, meme techniques — traduis-les en impact concret (ex: "fix lint" → "Correction de problemes de qualite de code", "update CI" → "Mise a jour du systeme de deploiement automatique")
          - Chaque puce commence par •
          - Donne suffisamment de detail pour que le lecteur comprenne ce qui a change et pourquoi c'est utile, 1-2 phrases par puce
          - N'inclus aucun lien ni URL
          - Si tous les commits sont purement techniques, reponds exactement : NO_USER_FACING_CHANGES

          Reponds avec UNIQUEMENT la liste a puces (ou NO_USER_FACING_CHANGES). Pas d'introduction, pas de conclusion.
          PROMPT_EOF

          jq -n --rawfile content /tmp/prompt.txt \
            '{model:"anthropic/claude-haiku-4-5",max_tokens:512,messages:[{role:"user",content:$content}]}' \
            > /tmp/ai_request.json

          HTTP_CODE=$(curl -s -o /tmp/ai_response.json -w "%{http_code}" \
            https://ai-gateway.vercel.sh/v1/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $AI_GATEWAY_API_KEY" \
            -d @/tmp/ai_request.json)

          if [ "$HTTP_CODE" != "200" ]; then
            echo "::warning::AI Gateway returned HTTP $HTTP_CODE — falling back to raw commits"
            echo "fallback=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          SUMMARY=$(jq -r '.choices[0].message.content' /tmp/ai_response.json)

          if [ "$SUMMARY" = "NO_USER_FACING_CHANGES" ]; then
            echo "no_user_changes=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "fallback=false" >> "$GITHUB_OUTPUT"
          echo "no_user_changes=false" >> "$GITHUB_OUTPUT"
          echo "summary<<EOF" >> "$GITHUB_OUTPUT"
          echo "$SUMMARY" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Post success to Slack
        if: steps.vercel.outputs.deploy_ok == 'true' && steps.commits.outputs.no_commits != 'true' && steps.ai.outputs.no_user_changes != 'true'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          RAW_COMMITS: ${{ steps.commits.outputs.commits }}
          AI_SUMMARY: ${{ steps.ai.outputs.summary }}
          AI_FALLBACK: ${{ steps.ai.outputs.fallback }}
        run: |
          BRANCH="${GITHUB_REF_NAME}"
          AUTHOR="${{ github.event.head_commit.author.name }}"

          if [ "$BRANCH" = "main" ]; then
            EMOJI=":rocket:"
            LABEL="production"
          else
            EMOJI=":construction:"
            LABEL="staging"
          fi

          if [ "$AI_FALLBACK" = "true" ]; then
            BODY=$(echo "$RAW_COMMITS" | sed 's/^/• /')
          else
            BODY="$AI_SUMMARY"
          fi

          TEXT="${EMOJI} *Disponible en ${LABEL}*\n\n${BODY}"

          curl -s -X POST "$SLACK_WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -d "$(jq -n --arg text "$TEXT" '{text: $text}')"

      - name: Promote staging deliverables to deployed
        if: steps.vercel.outputs.deploy_ok == 'true' && steps.commits.outputs.no_commits != 'true' && github.ref_name == 'main'
        continue-on-error: true
        env:
          AI_GATEWAY_API_KEY: ${{ secrets.AI_GATEWAY_API_KEY }}
          TRACKING_REPO_TOKEN: ${{ secrets.TRACKING_REPO_TOKEN }}
          TRACKING_REPO: ${{ vars.TRACKING_REPO }}
          TRACKING_BRANCH: ${{ vars.TRACKING_BRANCH }}
          RAW_COMMITS: ${{ steps.commits.outputs.commits }}
        run: |
          TRACKING_REPO_TOKEN=$(printf '%s' "$TRACKING_REPO_TOKEN" | tr -d '\n\r')
          echo "::group::Promote staging → deployed"

          # Fetch all MDX files from tracking repo
          CONTENT_RESP=$(curl -s \
            -H "Authorization: token $TRACKING_REPO_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/$TRACKING_REPO/contents/content?ref=$TRACKING_BRANCH")

          # Collect MDX files that are currently in staging
          STAGING_FILES="[]"
          for FILE_URL in $(echo "$CONTENT_RESP" | jq -r '.[]? | select(.name | endswith(".mdx") and .name != "commits.mdx") | .url'); do
            FILE_DATA=$(curl -s \
              -H "Authorization: token $TRACKING_REPO_TOKEN" \
              -H "Accept: application/vnd.github.v3+json" \
              "$FILE_URL?ref=$TRACKING_BRANCH")

            FILENAME=$(echo "$FILE_DATA" | jq -r '.name')
            SLUG="${FILENAME%.mdx}"
            FILE_CONTENT=$(echo "$FILE_DATA" | jq -r '.content // empty' | base64 -d 2>/dev/null || true)

            if [ -z "$FILE_CONTENT" ]; then continue; fi

            STATUS=$(echo "$FILE_CONTENT" | sed -n '/^---$/,/^---$/p' | grep '^status:' | sed 's/^status: *//')
            TITLE=$(echo "$FILE_CONTENT" | sed -n '/^---$/,/^---$/p' | grep '^title:' | sed 's/^title: *//')

            if [ "$STATUS" = "staging" ]; then
              STAGING_FILES=$(echo "$STAGING_FILES" | jq --arg s "$SLUG" --arg t "$TITLE" '. + [{slug: $s, title: $t}]')
            fi
          done

          STAGING_COUNT=$(echo "$STAGING_FILES" | jq 'length')
          echo "Found $STAGING_COUNT deliverable(s) in staging"

          if [ "$STAGING_COUNT" = "0" ]; then
            echo "No staging deliverables to promote"
            echo "::endgroup::"
            exit 0
          fi

          # Use AI to match merge commits to staging deliverables
          cat > /tmp/match_prompt.txt <<PROMPT_EOF
          Voici les commits qui viennent d'etre merges en production :

          $RAW_COMMITS

          Voici les livrables actuellement en staging :
          $(echo "$STAGING_FILES" | jq '.')

          Quels livrables parmi ceux en staging sont concernes par ces commits ?
          Reponds en JSON : un tableau de slugs. Exemple : ["socle-commun-leonard", "agent-guide-quentin"]
          Si aucun livrable ne correspond, reponds [].
          IMPORTANT : Reponds avec du JSON brut uniquement, pas de bloc de code markdown.
          PROMPT_EOF

          jq -n --rawfile content /tmp/match_prompt.txt \
            '{model:"anthropic/claude-haiku-4-5",max_tokens:256,messages:[{role:"user",content:$content}]}' \
            > /tmp/match_request.json

          HTTP_CODE=$(curl -s -o /tmp/match_response.json -w "%{http_code}" \
            https://ai-gateway.vercel.sh/v1/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $AI_GATEWAY_API_KEY" \
            -d @/tmp/match_request.json)

          if [ "$HTTP_CODE" != "200" ]; then
            echo "::warning::AI matching failed (HTTP $HTTP_CODE) — skipping promotion"
            echo "::endgroup::"
            exit 0
          fi

          MATCHED_SLUGS=$(jq -r '.choices[0].message.content' /tmp/match_response.json | sed '/^```\(json\)\?$/d')
          echo "AI matched slugs: $MATCHED_SLUGS"

          # Validate JSON array
          if ! echo "$MATCHED_SLUGS" | jq 'type == "array"' 2>/dev/null | grep -q true; then
            echo "::warning::AI response is not a JSON array — skipping"
            echo "::endgroup::"
            exit 0
          fi

          # Update each matched MDX file: staging → deployed, environment → prod
          echo "$MATCHED_SLUGS" | jq -r '.[]' | while read -r SLUG; do
            FILE_PATH="content/${SLUG}.mdx"
            echo "Promoting $FILE_PATH to deployed"

            EXISTING=$(curl -s \
              -H "Authorization: token $TRACKING_REPO_TOKEN" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/$TRACKING_REPO/contents/$FILE_PATH?ref=$TRACKING_BRANCH")

            SHA=$(echo "$EXISTING" | jq -r '.sha // empty')
            CURRENT=$(echo "$EXISTING" | jq -r '.content // empty' | base64 -d 2>/dev/null || true)

            if [ -z "$CURRENT" ] || [ -z "$SHA" ]; then
              echo "::warning::$FILE_PATH not found — skipping"
              continue
            fi

            # Replace status and environment in frontmatter
            UPDATED=$(echo "$CURRENT" | sed 's/^status: staging$/status: deployed/' | sed 's/^environment: staging$/environment: prod/')

            B64=$(echo "$UPDATED" | base64 -w 0)
            jq -n --arg msg "[bot] deployed: $SLUG" \
              --arg content "$B64" \
              --arg branch "$TRACKING_BRANCH" \
              --arg sha "$SHA" \
              '{message:$msg, content:$content, branch:$branch, sha:$sha}' \
              > /tmp/promote_payload.json

            if GH_TOKEN="$TRACKING_REPO_TOKEN" gh api \
              -X PUT \
              "/repos/$TRACKING_REPO/contents/$FILE_PATH" \
              --input /tmp/promote_payload.json > /tmp/promote_response.json 2>&1; then
              echo "Promoted $SLUG to deployed"
            else
              echo "::error::Failed to promote $SLUG"
              cat /tmp/promote_response.json
            fi
          done
          echo "::endgroup::"

      - name: Post failure to Slack
        if: steps.vercel.outputs.deploy_ok == 'false'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          BRANCH="${GITHUB_REF_NAME}"
          AUTHOR="${{ github.event.head_commit.author.name }}"

          TEXT=":x: *Echec du deploiement* sur ${BRANCH}\nMerge par _${AUTHOR}_ — le deploiement Vercel a echoue. Verifiez le dashboard Vercel."

          curl -s -X POST "$SLACK_WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -d "$(jq -n --arg text "$TEXT" '{text: $text}')"
